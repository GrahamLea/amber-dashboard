<!-- Copyright (c) 2022 Graham Lea. All rights reserved. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Amber Electric Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            border: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen,
            Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            background: #000000;
            color: #eeeeee;
            overflow-x: hidden;
        }

        .configButton, #closeButton {
            position: absolute;
            top: 2vh;
            left: 50vw;
            transform: translateX(-50%);
            z-index: 1;

            font-size: min(4vh, 4vw);
            padding: min(1vh, 1vw);
            width: min(6vh, 6vw);
            height: min(6vh, 6vw);
            border-radius: min(1vh, 1vw);
            vertical-align: center;

            background-color: rgba(200, 200, 200, 0.8);
            color: rgba(0, 0, 0, 0.6);
        }


        main {
            width: 100vw;
        }

        h1 {
            font-size: 5vw;
        }

        main#config {
            color: #333333;
            background-color: #eeeeee;
            text-align: center;
            padding: 2vh;
            min-height: 100vh;
            box-sizing: border-box;
        }

        #configData table {
            margin-top: 10vh;
            position: relative;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4vw;
            border-spacing: 5vh;
        }

        #configData table label {
            margin-right: 1vw;
        }

        #configData table th,
        #configData table td {
            text-align: left;
            vertical-align: baseline;
        }

        #configData label,
        #configData input,
        #configData select {
            font-size: 3vw;
            color: #333333;
            padding: 0.5vw;
        }

        #configData input[type=checkbox] {
            transform: scale(400%);
        }

        #configData input,
        #configData select {
            width: 50vw;
        }

        .configDataButtons {
            margin-top: 2vh;
        }

        #configData button {
            background-color: rgba(200, 200, 200, 0.8);
            font-size: 6vh;
            padding: 2vh;
            border-radius: 1vh;
        }

        main#loading {
            height: 100vh;
            font-size: 5vw;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-content: center;
            color: #777777;
        }

        main#dashboard {
            height: 100vh;
            display: flex;
            flex-direction: column;
            gap: 1vh;
            overflow: hidden;
        }

        #currentAndNext {
            width: 100vw;
            height: 40vh;
            display: flex;
            flex-direction: column;
        }

        #currentAndNextHeader {
            font-size: min(7vh, 10vw);
            width: 100vw;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
        }

        #currentAndNextHeader div {
            padding: 0.15em;
        }

        #currentAndNextPrices {
            position: relative;
            flex-grow: 1;
            display: flex;
            flex-direction: row;
            gap: min(1vh, 1vw);
        }

        #current, #next {
            transition: width 1s linear, background-color 1.5s ease;
        }

        #next {
            flex-grow: 1;
        }

        #currentAndNext .textContainer {
            position: absolute;
            z-index: 1;
            bottom: 1.5vh;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            gap: 0;
        }

        #currentAndNext #currentText.textContainer {
            z-index: 2;
        }

        #currentText {
            font-size: min(26vh, 31vw);
            left: 1.5vh;
        }

        #nextText {
            font-size: min(18vh, 21vw);
            text-align: right;
            right: 1.5vh;
        }

        #currentAndNext .label,
        #currentAndNext .description {
            filter: drop-shadow(0 0 1vh #000000);
            line-height: 1;
        }

        #currentAndNext .description {
            font-size: 15%;
            padding: 0 0.1em;
        }

        .unit {
            font-size: 50%;
        }

        .unit.dollars {
            position: relative;
            bottom: .5em;
        }

        #currentDescription {
            line-height: 1;
            padding: 0;
            margin: 0;
        }

        #nextDescription {
            text-align: right;
        }

        main#dashboard > section#future {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-end;
            flex-grow: 1;
            gap: 0.25vw;
            padding-top: 1em;
        }

        #future .high,
        #future .spike {
            color: #eeeeee;
        }

        #future .intervalStack {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        #future.hasNegatives .intervalStack {
            gap: 3vh;
        }

        #future .intervalStack.shortInterval {
            flex: 0.5;
        }

        #future .barContainer {
            flex-grow: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        #future .barContainer.negative {
            justify-content: flex-start;
        }

        #future .bar {
            position: relative;
            bottom: 0;
            transition: height 1s ease, background-color 1s ease, top 1s ease, bottom 1s ease;
        }

        #future .bar .icon {
            position: relative; /* to facilitate centering the icon */
            margin-top: 1vh;
            font-size: 1.5vw;
            color: #ffffff;
        }

        #future .bar .icon .fa-solid {
            position: absolute;
            font-size: 70%;
            left: 50%;
            transform: translateX(-50%);
        }

        #future .shortInterval .bar .icon .fa-solid {
            font-size: 35%;
        }

        #future .price {
            position: absolute;
            z-index: 1;
            top: -1.3em;
            left: 0;
            font-size: 2vh;
            font-weight: 500;
            white-space: nowrap;
            text-shadow: 0 0 0.3em #000;
        }

        #future .bar.negative .price {
            top: auto;
            bottom: -1.2em;
        }

        #future .timeContainer {
            width: 100%;
            height: 4.5em;
            font-size: max(1.6vh, 7pt);
            position: relative;
            left: 50%;
            transform: translateX(-0.5em);
        }

        #future .time {
            flex-grow: 0;
            color: #ffffff;
            padding: 0.3em 0;
            font-weight: 500;
            letter-spacing: .1em;
            white-space: nowrap;
            width: 0;
            overflow: visible;
            text-align: right;
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }

        #future .time .timePart.hour {
            font-size: 140%;
        }

        .bar.negative {
            background: #81ffcb !important;
        }

        .extremelyLow {
            background: #6aff6a repeating-radial-gradient(
                    circle at 50% 110%,
                    rgba(0, 0, 0, 0),
                    rgba(0, 0, 0, 0.2) 15%
            );
        }

        .extremelyLow.highlight {
            filter: brightness(1.1);
        }

        .veryLow {
            background: #01cb01;
        }

        .low {
            background: #dcdc03;
        }

        .neutral {
            background: darkorange;
        }

        .high {
            background: #ad0a0a;
        }

        .spike {
            background: #ef131a repeating-linear-gradient(
                    45deg,
                    rgba(0, 0, 0, 0),
                    rgba(0, 0, 0, 0) 10px,
                    rgba(0, 0, 0, 0.4) 10px,
                    rgba(0, 0, 0, 0.4) 20px
            );
        }

        .spike.highlight {
            filter: brightness(1.25);
        }

        .unknown {
            background: grey;
        }

        .slide-move {
            transition: transform 1s ease;
        }

        .slide-enter-active {
            position: relative !important;
            transition: opacity 1s ease, transform 1s ease;
        }

        .slide-leave-active {
            position: absolute !important;
            transition: opacity 1s ease, transform 1s ease;
        }

        .slide-enter {
            opacity: 0;
            transform: translateX(120%);
        }

        .slide-enter-to {
            opacity: 1;
            transform: translateX(0);
        }

        .slide-leave-to {
            opacity: 0;
            transform: translateX(-120%);
        }

        @keyframes flash {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0;
            }
        }
    </style>
</head>
<body>
<noscript>
    <strong>This dashboard uses JavaScript. Please enable it to continue.</strong>
</noscript>

<template id="app"></template>

<script type="text/x-template" id="price-template">
    <div class="price">
        <!-- Formatted like this to prevent extra HTML spaces -->
        <span v-if="Math.round(interval.perKwh) < 0">-</span><span
            v-if="Math.abs(Math.round(interval.perKwh)) >= 100" class="unit dollars">$</span
    >{{ formattedPrice(interval.perKwh) }}<span
            v-if="Math.abs(Math.round(interval.perKwh)) < 100" class="unit cents">c</span>
    </div>
</script>

<script type="text/x-template" id="time-template">
    <span>
        <span class="timePart" :class="{hour: isHour}">{{ formattedTime.timeStr }}</span>
        <span class="ampmPart" v-if="isHour || full">{{ formattedTime.ampm }}</span>
    </span>
</script>

<script type="text/x-template" id="dashboard-template">
    <div id="topLevelContainer">
        <main id="config" v-if="configMode">
            <button id="closeButton" @click="configMode = false">
                <i v-if="configMode" id="closeIcon" class="fa-solid fa-xmark"></i>
            </button>
            <div id="configData">
                <h1>Amber Electric Dashboard</h1>
                <table>
                    <tr>
                        <th>
                            <label for="apiKey">API Key:</label>
                            <sup>
                                <i class="fa-solid fa-circle-info"
                                   style="font-size: 50%"
                                   :title="'Get your personal Amber API Key from:\nhttps://app.amber.com.au/developers/\n\n' +
                                    'The dashboard stores your key safely in your browser\'s local storage.'"></i>
                            </sup>
                        </th>
                        <td>
                            <input id="apiKey" type="text" v-model="editableApiKey">
                            <div class="configDataButtons">
                                <button v-if="apiKeyDirty" @click="saveApiKey">Save</button>
                                <button v-if="apiKeyDirty" @click="editableApiKey = apiKey">Cancel
                                </button>
                            </div>
                            <div style="color: #ad0a0a; font-size: 50%" v-if="sitesRequestError">
                                Failed to retrieve Site list: {{ sitesRequestError }}
                            </div>
                            <div style="color: #ad0a0a; font-size: 50%"
                                 v-if="intervalsRequestError">
                                Failed to retrieve Forecast Intervals: {{ intervalsRequestError }}
                            </div>
                        </td>
                    </tr>

                    <tr>
                        <th><label for="site">Site:</label></th>
                        <td>
                            <select id="site" v-model="selectedSiteId"
                                    :disabled="sitesRequestError">
                                <option v-for="site in sites" :value="site.id">
                                    NMI: {{ site.nmi }} ({{ site.network }})
                                </option>
                            </select>
                        </td>
                    </tr>

                    <tr>
                        <th><label for="hoursForecastToShow">Max. Forecast Hours</label></th>
                        <td>
                            <input id="hoursForecastToShow" type="number" min="1" max="48"
                                   v-model.number="hoursForecastToShow">
                        </td>
                    </tr>

                    <tr>
                        <th><label for="highPriceLimit">High Price Threshold (c)</label></th>
                        <td>
                            <input id="highPriceLimit" type="number" min="0" max="2000"
                                   v-model.number="highPriceLimit">
                        </td>
                    </tr>

                    <tr>
                        <th><label for="silent">Silent Mode</label></th>
                        <td>
                            <input id="silent" type="checkbox" v-model="silent">
                        </td>
                    </tr>

                    <tr v-if="apiKey && selectedSiteId && !intervals">
                        <th></th>
                        <td>Loading...</td>
                    </tr>
                    <tr v-if="intervals">
                        <th></th>
                        <td style="color: #01cb01">Dashboard is ready!</td>
                    </tr>
                </table>

            </div>
        </main>
        <main id="loading" v-else-if="!intervals">
            <button class="configButton" @click="configMode = true">
                <i class="configIcon fa-solid fa-gear"></i>
            </button>
            <div>Loading Amber forecasts...</div>
        </main>
        <main id="dashboard" v-else>
            <button class="configButton" @click="configMode = true">
                <i class="configIcon fa-solid fa-gear"></i>
            </button>
            <section id="currentAndNext">

                <div id="currentAndNextHeader">
                    <div id="currentHeader">Now</div>
                    <div id="nextHeader">Next</div>
                </div>

                <div id="currentAndNextPrices">
                    <div id="current" :class="descriptor(currentGeneralInterval)"
                         :style="{width: currentIntervalRemainingPercentage + '%'}">
                    </div>
                    <div id="currentText" class="textContainer">
                        <price id="currentLabel" class="label"
                               :interval="currentGeneralInterval"
                               :trimHighPrices="trimHighCurrentAndNextPrices"></price>
                        <div id="currentDescription" class="description">
                            for the next
                            <template v-if="currentIntervalRemainingMinutesForDisplay == 1">minute</template>
                            <template v-else>{{ currentIntervalRemainingMinutesForDisplay }} minutes</template>
                            <sup v-if="this.shouldFakeNextInterval" style="animation: flash 2s infinite;">*</sup>
                        </div>
                    </div>

                    <div id="next" :class="descriptor(nextGeneralInterval)">
                    </div>
                    <div id="nextText" class="textContainer">
                        <price id="nextLabel" class="label"
                               :interval="nextGeneralInterval"
                               :trimHighPrices="trimHighCurrentAndNextPrices"></price>
                        <div id="nextDescription" class="description">
                            from
                            <time-display v-if="nextGeneralInterval" :time="nextGeneralInterval.startTime"
                                          :full="true"></time-display>
                        </div>
                    </div>
                </div>

            </section>

            <transition-group tag="section" id="future" name="slide" style="position: relative"
                              :class="{hasNegatives: anyFutureNegativePrices}">
                <div v-for="(interval, i) in futureIntervals"
                     class="intervalStack"
                     :class="{shortInterval: interval.duration !== 30}"
                     :key="interval.nemTime">
                    <div class="barContainer" :class="{ negative: Math.round(interval.perKwh) < 0 }">
                        <div class="bar"
                             :class="[descriptor(interval), { negative: Math.round(interval.perKwh) < 0 }]"
                             :style="{height: `${heightPercentForBar(interval) * 100}%`,
                                        ...(Math.round(interval.perKwh) >= 0
                                            ? {bottom: `${(1 - positiveBarSpaceRatio) * 100}%`}
                                            : {top: `${positiveBarSpaceRatio * 100}%`})}">
                            <div v-if="descriptor(interval) === 'spike'" class="icon">
                                <i class="fa-solid fa-warning"></i>
                            </div>
                            <price class="price" :interval="interval"
                                   v-if="i === 0 || significantPriceChangeIntervals.includes(i)"></price>
                        </div>
                    </div>
                    <div class="timeContainer">
                        <div class="time">
                            <time-display v-if="showTime(interval)" :time="interval.startTime"></time-display>
                        </div>
                    </div>
                </div>
            </transition-group>
        </main>
    </div>
</script>

<!--<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>-->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/luxon@1.28.0/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js"></script>

<script>
    const TEST_MODE = false;
    const TEST_ANIMATION = false;
    const TWENTY_FOUR_HOURS_IN_MS = 24 * 60 * 60 * 1000;
    const DEFAULT_HOURS_FORECAST_TO_SHOW = 18;
    const DEFAULT_HIGH_PRICE_LIMIT = 100;

    const BAR_THRESHOLD_1 = 20;
    const BAR_THRESHOLD_2 = 40;
    const BAR_THRESHOLD_3 = 80;
    const BAR_THRESHOLD_4 = 1700;

    const decimalFormatTrimmed = new Intl.NumberFormat("en-AU",
        {style: "decimal", minimumFractionDigits: 1, maximumFractionDigits: 1});
    const decimalFormatFull = new Intl.NumberFormat("en-AU",
        {style: "decimal", minimumFractionDigits: 2, maximumFractionDigits: 2});

    const DateTime = luxon.DateTime;

    function nowNemTime() {
        return DateTime.now().setZone('+10:00');
    }

    function flashExtremeElements() {
        const nowMs = Date.now();
        const on = (nowMs / 1000) % 2 <= 1;
        document.querySelectorAll('.spike, .extremelyLow').forEach(bar => {
            if (on) {
                bar.classList.add("highlight");
            } else {
                bar.classList.remove("highlight");
            }
        });
    }

    setInterval(flashExtremeElements, 1000);

    // Courtesy of Houshalter on SO: https://stackoverflow.com/a/29641185/243104
    const audioCtx = new (window.AudioContext || window.webkitAudioContext || window.audioContext);

    async function loadTestData() {
        const data = await (await fetch("test-data.json")).json();
        // Overwrite the timestamps to make them go from now forwards...
        let time = DateTime.now().setZone("UTC")
        time = time.set({minutes: (time.minute - time.minute % 5), seconds: 0, milliseconds: 0})
        for (const interval of data.filter(i => i.channelType === "general" && ["CurrentInterval", "ForecastInterval"].includes(i.type))) {
            interval.startTime = time.set({minute: interval.duration === 30 ? time.minute >= 30 ? 30 : 0 : time.minute}).toISO()
            time = time.plus({minutes: interval.duration})
            interval.endTime = time.toISO()
        }
        return data
    }

    async function beep({duration, frequency, volume, type}) {
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        if (volume) {
            gainNode.gain.value = volume;
        }
        if (frequency) {
            oscillator.frequency.value = frequency;
        }
        if (type) {
            oscillator.type = type;
        }
        const promise = new Promise(resolve => {
            oscillator.onended = resolve
        })

        oscillator.start(audioCtx.currentTime);
        oscillator.stop(audioCtx.currentTime + ((duration || 500) / 1000));
        return promise;
    }

    async function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms))
    }

    async function playAlert() {
        await beep({duration: 300, frequency: 783.99, volume: 0.3, type: 'triangle'})
        await sleep(80)
        await beep({duration: 300, frequency: 783.99, volume: 0.3, type: 'triangle'})
        await sleep(80)
        await beep({duration: 150, frequency: 783.99, volume: 0.3, type: 'triangle'})
    }

    Vue.component('price', {
        props: ['interval', 'trimHighPrices'],
        template: '#price-template',

        methods: {
            formattedPrice(centsPerKwh) {
                const roundedCents = Math.abs(Math.round(centsPerKwh));
                if (roundedCents < 100) {
                    return roundedCents
                } else if (roundedCents < 1000) {
                    return this.trimHighPrices
                        ? decimalFormatTrimmed.format(roundedCents / 100)
                        : decimalFormatFull.format(roundedCents / 100);
                } else {
                    return Math.round(roundedCents / 100)
                }
            },
        }
    });

    Vue.component('time-display', {
        props: ['time', 'full'],
        template: '#time-template',

        computed: {
            dateTime() {
                return DateTime.fromISO(this.time).toLocal()
            },
            isHour() {
                return this.dateTime.minute === 0
            },
            formattedTime() {
                const [timeStr, ampm] = this.dateTime.toLocaleString({
                    hour: 'numeric',
                    minute: this.isHour && !this.full ? undefined : 'numeric',
                    hour12: true
                }).split(" ");
                return {
                    timeStr,
                    ampm
                };
            },
        }
    });

    const app = new Vue({
        el: "#app",
        template: "#dashboard-template",
        data: function () {
            return {
                configMode: true,
                loadedTime: new Date(),
                apiKey: null,
                editableApiKey: null,
                selectedSiteId: null,
                lastRequestMinute: -1,
                sites: null,
                sitesRequestError: null,
                intervalsRequestError: null,
                intervals: null,
                hoursForecastToShow: 18,
                highPriceLimit: 100,
                silent: false,
                dateTimeNow: -1,
                width: 900,
                height: 600,
            }
        },
        computed: {
            showOddTimes() {
                return (this.width / this.futureIntervals?.length ?? 20) > 17
            },
            trimHighCurrentAndNextPrices() {
                return this.width / this.height < 1.1;
            },
            apiKeyDirty() {
                return this.editableApiKey !== this.apiKey;
            },
            generalIntervals() {
                return this.intervals?.filter(interval => interval.channelType === "general");
            },
            shouldFakeNextInterval() {
                return this.actualCurrentGeneralInterval
                    && this.dateTimeNow > DateTime.fromISO(this.actualCurrentGeneralInterval.endTime)
            },
            actualCurrentGeneralInterval() {
                return this.generalIntervals?.filter(interval => interval.type === "CurrentInterval")[0];
            },
            currentGeneralInterval() {
                if (this.shouldFakeNextInterval) {
                    return this.actualNextGeneralInterval
                }
                return this.actualCurrentGeneralInterval;
            },
            actualNextGeneralInterval() {
                return this.forecastGeneralIntervalsSorted ? this.forecastGeneralIntervalsSorted[0] : null;
            },
            nextGeneralInterval() {
                return this.shouldFakeNextInterval && this.forecastGeneralIntervalsSorted
                    ? this.forecastGeneralIntervalsSorted[1]
                    : this.actualNextGeneralInterval;
            },
            currentIntervalRemainingMinutes() {
                return this.currentGeneralInterval ?
                    Math.max(0, DateTime.fromISO(this.currentGeneralInterval.endTime).diff(this.dateTimeNow, 'minutes').minutes) :
                    0;
            },
            currentIntervalRemainingMinutesForDisplay() {
                return Math.floor(this.currentIntervalRemainingMinutes + 1);
            },
            currentIntervalRemainingPercentage() {
                return this.currentGeneralInterval ?
                    this.currentIntervalRemainingMinutes / this.currentGeneralInterval.duration * 100
                    : 0;
            },
            forecastGeneralIntervalsSorted() {
                return this.generalIntervals ?
                    _(this.generalIntervals)
                        .filter(interval => interval.type === "ForecastInterval")
                        .sortBy("nemTime")
                        .value()
                    : null
            },
            futureIntervals() {
                return this.forecastGeneralIntervalsSorted ?
                    _(this.forecastGeneralIntervalsSorted)
                        .slice(this.shouldFakeNextInterval ? 2 : 1)
                        .filter(i => DateTime.fromISO(i.startTime).diffNow('hours').hours <= this.hoursForecastToShow)
                        .value()
                    : null
            },
            significantPriceChangeIntervals() {
                let lastSignificantPrice = null

                return _(this.futureIntervals).map((interval, index) => {
                    if (!lastSignificantPrice) {
                        lastSignificantPrice = interval.perKwh
                        return index
                    }
                    const priceA = interval.perKwh;
                    const priceB = lastSignificantPrice;
                    const diff = Math.abs(priceA - priceB)
                    const significantDiff = Math.max(2, Math.min(priceA, priceB) / 10)
                    if ((priceA < 0 && priceB > 2) || diff > significantDiff) {
                        lastSignificantPrice = interval.perKwh
                        return index
                    } else {
                        return null
                    }
                }).compact().value()
            },
            anyFutureNegativePrices() {
                return _(this.futureIntervals).some(i => Math.round(i.perKwh) < 0)
            },
            maxFutureNegativePrice() {
                return _(this.futureIntervals)
                        ?.map(i => i.perKwh)
                        .filter(p => Math.round(p) < 0)
                        .max()
                    ?? 0
            },
            maxNegativeBarPrice() {
                return Math.min(100, Math.abs(this.maxFutureNegativePrice))
            },
            positiveBarSpaceRatio() {
                return 1 - (0.25 * this.maxNegativeBarPrice / 100)
            }
        },
        methods: {
            saveApiKey() {
                this.apiKey = this.editableApiKey;
                this.loadSites();
            },
            async loadSites() {
                if (!this.apiKey) {
                    return false;
                }
                this.sitesRequestError = null;
                const url = `https://api.amber.com.au/v1/sites/`;
                console.log("Requesting sites", {url});
                const response = await fetch(url, {
                    accept: "application/json",
                    headers: {"Authorization": `Bearer ${this.apiKey}`}
                });
                if (response.ok) {
                    response.json().then(data => this.sites = data)
                    return true
                } else {
                    this.sitesRequestError = `Server response: ${response.status}`;
                    return false
                }
            },
            async loadIntervals() {
                if (!this.apiKey || !this.selectedSiteId) {
                    return;
                }
                this.intervalsRequestError = null;
                const startDate = nowNemTime().set({minutes: 0}).toISODate();
                const endDate = nowNemTime().plus({hours: (this.hoursForecastToShow + 1)}).toISODate();
                const url = `https://api.amber.com.au/v1/sites/${this.selectedSiteId}/prices`
                    + `?startDate=${startDate}`
                    + `&endDate=${endDate}`;
                console.log("Requesting forecasts", {
                    hoursForecastToShow: this.hoursForecastToShow,
                    startDate,
                    endDate,
                    url
                });
                if (TEST_MODE) {
                    this.intervals = await loadTestData();
                    console.log({forecastGeneralIntervalsSorted: this.forecastGeneralIntervalsSorted.length})
                    console.log({forecastGeneralIntervalsSorted: this.forecastGeneralIntervalsSorted[0]})
                    console.log({hoursDiff: DateTime.fromISO(this.forecastGeneralIntervalsSorted[2].startTime).diffNow('hours').hours})
                    console.log({futureIntervals: this.futureIntervals[0]})
                    // For testing...
                    this.currentGeneralInterval.perKwh = 888;
                    this.currentGeneralInterval.descriptor = 'spike';
                    // this.forecastGeneralIntervalsSorted[1].perKwh = 2000;
                    // this.forecastGeneralIntervalsSorted[1].descriptor = "extremelyHigh";
                    this.forecastGeneralIntervalsSorted[10].perKwh = 2000;
                    this.forecastGeneralIntervalsSorted[10].descriptor = "extremelyHigh";
                    // this.forecastGeneralIntervalsSorted[1].perKwh = 10;
                    // this.forecastGeneralIntervalsSorted[1].descriptor = "veryLow";
                    this.forecastGeneralIntervalsSorted[3].perKwh = -245;
                    this.forecastGeneralIntervalsSorted[3].descriptor = "veryLow";
                    this.possiblyPlayAlert()
                    console.log({
                        maxNegativeBarPrice: this.maxNegativeBarPrice,
                        positiveBarSpaceRatio: this.positiveBarSpaceRatio
                    })
                    console.log("<<< loadIntervals()")
                    return
                }
                try {
                    const response = await fetch(url, {
                        accept: "application/json",
                        headers: {"Authorization": `Bearer ${this.apiKey}`}
                    })
                    if (response.ok) {
                        this.intervals = await response.json()
                        this.possiblyPlayAlert()
                        return true
                    } else {
                        this.intervalsRequestError = `Server response: ${response.status}`;
                        return false
                    }
                } catch (e) {
                    this.intervalsRequestError = `${e}`;
                }
            },
            maybeLoadIntervals() {
                if (!this.apiKey || !this.selectedSiteId) {
                    return;
                }
                if (new Date() - this.loadedTime > TWENTY_FOUR_HOURS_IN_MS) {
                    location.reload();
                }
                const now = new Date();
                const minuteNow = now.getMinutes();
                if (minuteNow !== this.lastRequestMinute && now.getSeconds() > 20) {
                    this.lastRequestMinute = minuteNow;
                    this.loadIntervals();
                }
                this.dateTimeNow = DateTime.now()
                if (TEST_ANIMATION && this.generalIntervals && (new Date().getSeconds() % 5 === 0)) {
                    _(this.generalIntervals).forEach(interval => {
                        if (Math.random() < 0.2) {
                            interval.perKwh = interval.perKwh + (15 * (Math.random() - 0.5))
                        }
                        if (Math.random() < 0.2) {
                            interval.descriptor = _.sample([
                                'extremelyLow', 'veryLow', 'low', 'neutral', 'high', 'spike'
                            ])
                        }
                    })
                    this.intervals = [...this.intervals]
                    this.hoursForecastToShow += Math.random() < 0.5 ? 1 : -1
                }
            },
            possiblyPlayAlert() {
                // Play an alert every 5 minutes if there's currently a spike
                let isCurrentlyASpike = this.descriptor(this.currentGeneralInterval) === "spike";
                let isZerothMinute = (new Date().getMinutes() % 5) < 1;
                if (!this.silent && isCurrentlyASpike && isZerothMinute) {
                    playAlert();
                }
            },
            descriptor(interval) {
                if (interval.spikeStatus === "spike" ||
                    interval.spikeStatus === "potential" ||
                    interval.perKwh > this.highPriceLimit) {
                    return "spike"
                }
                return interval.descriptor || 'unknown'
            },
            heightPercentForBar(interval) {
                const price = interval.perKwh;
                if (price < 0) {
                    return Math.min(this.maxNegativeBarPrice, Math.abs(price))
                        / this.maxNegativeBarPrice * (1 - this.positiveBarSpaceRatio);
                }
                let positiveBarRatio = 0;
                if (price > BAR_THRESHOLD_4) {
                    positiveBarRatio = 1.0;
                } else if (price > BAR_THRESHOLD_3) {
                    positiveBarRatio = 0.75 + (0.25 * ((price - BAR_THRESHOLD_3) / (BAR_THRESHOLD_4 - BAR_THRESHOLD_3)));
                } else if (price > BAR_THRESHOLD_2) {
                    positiveBarRatio = 0.50 + (0.25 * ((price - BAR_THRESHOLD_2) / (BAR_THRESHOLD_3 - BAR_THRESHOLD_2)));
                } else if (price > BAR_THRESHOLD_1) {
                    positiveBarRatio = 0.25 + (0.25 * ((price - BAR_THRESHOLD_1) / (BAR_THRESHOLD_2 - BAR_THRESHOLD_1)));
                } else {
                    positiveBarRatio = (0.25 * price / BAR_THRESHOLD_1);
                }
                return positiveBarRatio * this.positiveBarSpaceRatio;
            },

            handleResize() {
                this.width = window.innerWidth
                this.height = window.innerHeight
            },

            showTime(interval) {
                const minute = DateTime.fromISO(interval.startTime).minute
                if (interval.duration !== 30) {
                    return minute % 30 === 0
                }
                const hour = DateTime.fromISO(interval.startTime).hour
                return this.showOddTimes ? minute === 0 : (minute === 0 && (hour % 2 === 0))
            }
        },
        watch: {
            apiKey(newKey) {
                console.log("New API key set");
                localStorage.setItem("apiKey", newKey);
                this.editableApiKey = this.apiKey;
                this.intervals = null;
                this.selectedSiteId = null;
            },
            sites(newSites) {
                console.log("Sites downloaded: ", newSites);
                if (newSites && newSites.length === 1) {
                    if (this.selectedSiteId === null) {
                        this.selectedSiteId = newSites[0].id;
                    } else if (!_.map(newSites, "id").includes(this.selectedSiteId)) {
                        console.log("Current Selected Site ID not in new Sites list. Unsetting");
                        this.selectedSiteId = null;
                        this.configMode = true;
                    }
                }
            },
            selectedSiteId(newValue) {
                console.log("Selected Site ID changed: ", newValue);
                localStorage.setItem("selectedSiteId", newValue);
                if (newValue) {
                    this.lastRequestMinute = -1;
                    this.maybeLoadIntervals();
                }
            },
            hoursForecastToShow(newValue) {
                localStorage.setItem("hoursForecastToShow", newValue);
            },
            highPriceLimit(newValue) {
                localStorage.setItem("highPriceLimit", newValue);
            },
            silent(newValue) {
                localStorage.setItem("silent", newValue);
            },
        },
        async mounted() {
            this.width = window.innerWidth
            this.hoursForecastToShow = Number(localStorage.getItem("hoursForecastToShow")) || DEFAULT_HOURS_FORECAST_TO_SHOW;
            this.highPriceLimit = localStorage.getItem("highPriceLimit") || DEFAULT_HIGH_PRICE_LIMIT;
            this.silent = localStorage.getItem("silent") === "true" || localStorage.getItem("silent") === true;
            const storedApiKey = localStorage.getItem("apiKey");
            if (storedApiKey) {
                this.apiKey = storedApiKey;
                const storedSelectedSiteId = localStorage.getItem("selectedSiteId");
                if (storedSelectedSiteId) {
                    this.selectedSiteId = storedSelectedSiteId;
                    if (await this.loadSites()) {
                        this.configMode = false;
                    }
                } else {
                    this.loadSites();
                }
            }
            this.loadIntervals().then(() => {
                    setInterval(this.maybeLoadIntervals, 1000);
                }
            )
            window.addEventListener('resize', this.handleResize);
        },
        beforeDestroy() {
            window.removeEventListener('resize', this.handleResize);
        }
    });
</script>
<script src="https://kit.fontawesome.com/547b6e0b99.js" crossorigin="anonymous" async></script>

</body>
</html>
